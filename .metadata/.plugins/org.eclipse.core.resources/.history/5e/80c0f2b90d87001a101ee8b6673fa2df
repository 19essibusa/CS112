/*
 * List.h
 *
 *  Created on: Mar 10, 2020
 *            Author: Julien Camy (jjc34)
 *      Author: Einstein Essibu(se27)

 */

#ifndef LIST_H_
#define LIST_H_
#include <iostream>
#include <fstream>
using namespace std;

typedef double Item;

template <class Item>
class List {

public:
	List();
	unsigned getSize() const { return mySize; }
	Item getFirst() const;
	Item getLast() const;
	void append(const Item& item);
	~List();
	List(const List& original);
	List<Item>& operator=(const List& original);
	bool operator!=(const List& list2);
	void writeTo(ostream& out) const;
	void readFrom(const string& fileName);
	int getIndexOf(const Item& it);
	Item remove(int index);

private:
	struct Node{
		Node();
		~Node();
		Node(const Item& it, Node* next);
		Item myItem;
		Node* myNext;
	};
	Node* myFirst;
	Node* myLast;
	unsigned mySize;

	friend class ListTester;
};

template <class Item>

#include "List.h"
#include <stdexcept>
#include <fstream>
#include <fstream>
#include <cstdlib>
#include <cassert>

using namespace std;


/*
 * Initialize default List
 */
template <class Item>
List<Item>::List() {
	mySize = 0;
	myFirst = myLast = nullptr;

}

/*
 * Initialize default Node
 */
template <class Item>
List<Item>::Node::Node()
{
	myItem = Item();
	myNext = nullptr;
}
/*
 * Explicit Node constructor
 */
template <class Item>
List<Item>::Node::Node(const Item& it, Node* next){
	myItem = it;
	myNext = next;

}
/*<
 * Append items to end of list
 */
template <class Item>
void List<Item>::append(const Item& item){
	Node* nPtr = new Node(item, nullptr);
	if (mySize == 0) { // empty case
		myFirst = nPtr;
	} else {
		myLast->myNext = nPtr;
	}
	myLast = nPtr;
	++mySize;
}

/*
 * return item in first node
 */
template <class Item>
Item List<Item>::getFirst() const{
	if (mySize <= 0 || myFirst == NULL){
		throw underflow_error("No items in List");
	}else{
		return myFirst->myItem;
	}
}
/*
 * return item in last node
 */
template <class Item>
Item List<Item>::getLast() const{
	if (mySize <= 0 || myFirst == NULL){
		throw underflow_error("No items in List");
	}else{
		return myLast->myItem;
	}
}
/*
 * delete list
 */
template <class Item>
List<Item>::~List() {
	delete myFirst;          // delete first node, invoking ~Node() (does nothing if myFirst == NULL)
	myFirst = myLast = NULL; // clear myFirst and myLast (optional)
	mySize = 0;              // clear mySize (optional)
}

/*
 * Delete Node
 */
template <class Item>
List<Item>::Node::~Node() {
	delete myNext;       // delete the next node, invoking ~Node() in it
	// (does nothing if myNext == NULL)
}

/*
 * deep copy constructor
 */
template <class Item>
List<Item>::List(const List& original) {
	myFirst = myLast = NULL;       //  set pointers
	mySize = 0;                    //   and size to 'empty' values
	Node* oPtr = original.myFirst; //  start at the first node
	while (oPtr != NULL) {         //  while there are nodes to copy:
		append(oPtr->myItem);       //   append the item in that node
		oPtr = oPtr->myNext;        //   advance to next node
	}
}

/*
 * Assignment operation
 */
template <class Item>
List<Item>& List<Item>::operator=(const List& original) {
	if (this != &original){
		delete myFirst;
		myFirst = myLast = NULL;
		mySize = 0;
		Node* nPtr;
		nPtr = original.myFirst;
		while (nPtr != NULL){
			append(nPtr->myItem);
			nPtr = nPtr-> myNext;
		}

	}
	return *this;
}


/* Defines the != operator, returns true if this is not equal, false if it is equal
 * @param l2, type List, a list to be compared
 * Return: true or false, and a type bool
 * Author: Einstein Essibu
 */
template <class Item>
bool List<Item>::operator!=(const List& list2) {
	if (mySize == list2.mySize) {
		Node * temp2 = list2.myFirst;
		for (Node * temp1 = myFirst; temp1; temp1 = temp1->myNext) {
			if (temp1->myItem != temp2->myItem) {
				return true;
			}
			temp2 = temp2->myNext;
		}
		return false;
	}
	return true;
}

/* Writes the items of the nodes of the list to a file
 * @param out, type ostream
 * Precondition: an open ofstream
 * Author: Einstein Essibu
 */
template <class Item>
void List<Item>::writeTo(ostream& out) const {
	for (Node * temp = myFirst; temp; temp = temp->myNext) {
		out << temp->myItem << endl;
	}
}

/* read the values in a list from a file and places them in another list
 * @param fileName, type string
 * Author: Einstein Essibu
 */
template <class Item>
void List<Item>::readFrom(const string& fileName) {
	delete myFirst;
	ifstream fin(fileName.c_str());

	Item num;
	while (true) {
		if (fin >> num) {
			append(num);
		} else {
			break;
		}
	}
	fin.close();
}

/* finds the index of a given item in a list
 * @param it, type Item
 * Author: Einstein Essibu
 */
template <class Item>
int List<Item>::getIndexOf(const Item& it) {
	unsigned i = 0;
	for (Node * temp = myFirst; temp; temp = temp->myNext) {
		if (temp->myItem == it) {
			return i;
		}
		i++;
	}
	return -1;
}


/* remove a node at a given index
 * @param index, type int
 * Author: Einstein Essibu
 */
template <class Item>
Item List<Item>::remove(int index) {
	//If the list is empty
	if (mySize == 0) {
		throw range_error("The list is empty!");

		//If the size is 1, delete the list
	} else if (mySize == 1) {
		Item item = myFirst->myItem;
		delete myFirst;
		mySize = 0;
		myFirst = NULL;
		myLast = NULL;
		return item;

		//If the size is greater than 1
	} else {
		if (index < 0) {
			index = 0;
		} else if (index > mySize - 1) {
			index = mySize - 1;
		}
		Node* temp = myFirst;

		//Removing first node
		if (index == 0) {
			mySize--;
			Item item = temp->myItem;
			myFirst = temp->myNext;
			temp->myNext = NULL;
			delete temp;
			return item;

			//Removing any other node
		} else {
			for (unsigned i = 0; i < index; i++) {
				if (i == index - 1) {
					mySize--;
					Node * temp2 = temp->myNext;
					Item item = temp2->myItem;
					temp->myNext = temp->myNext->myNext;
					if (temp->myNext) {
						temp->myNext->myNext = NULL;
						temp2->myNext = NULL;
					}
					if (!temp->myNext) {
						myLast = temp;
					}
					delete temp2;
					return item;
				}
				temp = temp->myNext;
			}
		}
	}
}

#endif /* LIST_H_ */
