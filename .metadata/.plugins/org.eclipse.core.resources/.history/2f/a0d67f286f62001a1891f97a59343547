/* Matrix.cpp defines Matrix class methods.
 * Student Name: Danish Ansari (da35) and Colton Smits (cjs74)
 * Date: 03/05/2020
 * Begun by: Joel Adams, for CS 112 at Calvin University.
 */
#ifndef VEC_H_
#define VEC_H_

#include <iostream>
using namespace std;

#include "Vec.h"
#include <stdexcept>
#include <fstream>
using namespace std;

template<class Item>
class Vec {
public:
	Vec();
	virtual ~Vec();
	Vec(unsigned size);
	Vec(const Vec<Item>& original);
	Vec<Item>& operator=(const Vec<Item>& original);
	unsigned getSize() const {return mySize;}
	void setItem(unsigned index, const Item& it);
	Item getItem(unsigned index) const;
	void setSize(unsigned newSize);
	bool operator==(const Vec<Item>& v2) const;
	void writeTo(ostream& out) const;
	void readFrom(istream& in);
	const Item& operator [](unsigned index)const;
	Item& operator [] (unsigned index);
	bool operator!=(const Vec<Item>& v2) const;
	Vec<Item> operator+(Vec<Item> v1);
	Vec<Item> operator-(Vec<Item> v1);
	double operator*(Vec<Item> v1);
	void readFrom(const string fileName);
	void writeTo(const string fileName);

private:
	unsigned mySize;
	Item * myArray;
	friend class VecTester;
};


//The Default value Constructor: initializes all values to 0
template<class Item>
Vec<Item>::Vec() {
	mySize = 0;
	myArray = NULL;
}

//The Destructor
//Purpose: delete array and pointers and free their memory
//Precondition: Vec should exist
template<class Item>
Vec<Item>::~Vec() {
	delete[] myArray;
	mySize = 0;
	myArray = NULL;
}

//Explicit Value Constructor: Sets the values as entered
//Parameters: size of vector
//Preconditions: size must be a number
//Postconditions: vector of size is made
template<class Item>
Vec<Item>::Vec(unsigned size) {
	mySize = size;
	if (size){
		myArray = new Item[size]();
	}
	else {
		myArray = NULL;
	}
}


//Copy Constructor: Makes a copy of the original array
//Parameters: vector
//Preconditions: vector passed in exists
//Postconditions: the vector passed is copied
template<class Item>
Vec<Item>::Vec(const Vec<Item>& original) {
	mySize = original.mySize;
	if (mySize !=0) {
		myArray = new Item [mySize]();
		for (unsigned i=0; i < mySize; i++) {
			myArray[i] = original.myArray[i];
		}
	}
	else {
		myArray = NULL;
	}
}

//makes a copy, but overwrites the previous values
//Parameters: vector
//Preconditions:vector exists
//Postconditions: copies passed vectors values into this array
//Return Value: vector location
template<class Item>
Vec<Item>& Vec<Item>::operator=(const Vec<Item>& original) {
	if (mySize == original.mySize && myArray == original.myArray) {

	}
	else {
		delete[] myArray;
		mySize = 0;
		myArray = NULL;

		mySize = original.mySize;
		if (mySize) {
			myArray = new Item [mySize]();
			for (unsigned i=0; i < mySize; i++) {
				myArray[i] = original.myArray[i];
			}
		}
		else {
			myArray = NULL;
		}

	}
	return *this;
}

//Sets the value in said index to said item
//Parameters: index & Item
//Preconditions: index must be within range, Item must be number
//Postconditions: array value at index is now Item
template<class Item>
void Vec<Item>::setItem(unsigned index, const Item& it) {
	if (mySize<index+1) {
		throw range_error("Index is out of range");
	}
	myArray[index] = it;

}

//Returns the Item in the said Index
//Parameters: index
//Preconditions: index must be within range
//Postconditions: Item at array[index] is returned
//Return Value: Item at array[index]
template<class Item>
Item Vec<Item>::getItem(unsigned index) const {
	if (mySize<index+1) {
		throw range_error("Index is out of range");
	}
	return myArray[index];
}


//Changes the size of an existing vector to a new size
//Parameters: newsize
//Postconditions: vector size is changed to newsize
template<class Item>
void Vec<Item>::setSize(unsigned newSize) {

	if (newSize==0) {
		mySize = newSize;
		delete [] myArray;
		myArray = NULL;
		return;
	}
	if (mySize == newSize) {return;}

	if(newSize > mySize) {
		Item * newPtr = new Item[newSize]();
		for (unsigned i=0; i < mySize; i++) {
			newPtr[i] = myArray[i];
		}
		delete [] myArray;
		mySize = newSize;
		myArray = newPtr;
		return;
	}

	if (newSize < mySize) {
		Item *newPtr = new Item[newSize]();
		for (unsigned i = 0; i< newSize; i++) {
			newPtr[i] = myArray[i];
		}
		delete [] myArray;
		mySize = newSize;
		myArray = newPtr;
	}
}


//Operator ==: Compares the array on the left to the right and returns true if
//all the items match
//Parameters: vector
//Preconditions: vector exists
//Postconditions: returns true or false based on whether every value matches or not
//Return Value: bool
template<class Item>
bool Vec<Item>::operator==(const Vec<Item>& v2) const {
	if (mySize != v2.mySize){
		return false;
	}
	for (unsigned i = 0;i<mySize;i++){
		if (myArray[i] != v2.getItem(i)){
			return false;
		}
	}
	return true;
}


//Displays the vector on the screen/ or write it to a file
//Parameters: opened file
//Preconditions: file is open
//Postconditions: values from array are written into the file
template<class Item>
void Vec<Item>::writeTo(ostream& out) const {
	for (unsigned i=0; i< mySize; i++){
		out << myArray[i];
		out << " ";
	}
}

//Reads from an infile stream or from the keyboard
//Parameters: opened file
//Preconditions: file is open
//Postconditions: values in the file are written into the array
template<class Item>
void Vec<Item>::readFrom(istream& in) {
	string str;
	int num;
	for (unsigned i=0; i< mySize; i++){
		in >> str;
		num = atoi(str.c_str());
		myArray[i] =  num;
	}
}

//Parameters: index
//Preconditions: index is within range
//Postconditions: returns value at myArray[index]
//Return Value: Item
template<class Item>
const Item& Vec<Item>::operator [](unsigned index)const{
	if (mySize < index+1) {
		throw range_error("Index is out of range");
	}
	else{
		return myArray[index];
	}

}

//Parameters: index
//Preconditions: index is within range
//Postconditions: returns value at myArray[index]
//Return Value: Item
template<class Item>
Item& Vec<Item>::operator [] (unsigned index){
	if (mySize < index+1) {
		throw range_error("Index is out of range");
	}
	else {
		return myArray[index];
	}

}

//Parameters: vector
//Preconditions: vector exists
//Postconditions: bool returns true if not every value is the same between the passed
// vector and myArray, and false if they do match
//Return Value: bool
template<class Item>
bool Vec<Item>::operator!=(const Vec<Item>& v2) const {
	if (mySize != v2.mySize){
		return true;
	}
	for (unsigned i = 0 ;i<mySize; i++){
		if (myArray[i] != v2.getItem(i)){
			return true;
		}
	}
	return false;
}

//Parameters: vector
//Preconditions: vectors must be of same size
//Postconditions: vector of added values is returned
//Return Value: vector

template<class Item>
Vec<Item> Vec<Item>::operator+(Vec<Item> v1) {
	Vec<Item> returnVec;
	if (v1.mySize != mySize){
		throw invalid_argument("The vectors aren't of the same size!");
	}
	returnVec.setSize(mySize);
	for (unsigned i=0; i < returnVec.mySize; i++){
		returnVec.myArray[i] = myArray[i] + v1[i] ;
	}
	return returnVec;
}

//Parameters: vector
//Preconditions: vectors must be same size
//Postconditions: vector of subtracted values of vectors is returned
//Return Value: vector

template<class Item>
Vec<Item> Vec<Item>::operator-(Vec<Item> v1) {
	Vec<Item> returnVec;
	if (v1.mySize != mySize){
		throw invalid_argument("The vectors aren't of the same size!");
	}
	returnVec.setSize(mySize);
	for (unsigned i=0; i < returnVec.mySize; i++){
		returnVec.myArray[i] = myArray[i] - v1[i] ;
	}
	return returnVec;
}

//Parameters: vector
//Preconditions: vectors must be same size
//Postconditions: sum of all multiples of same index is returned
//Return Value: double

template<class Item>
double Vec<Item>::operator*(Vec<Item> v1) {
	double returnValue;
	double product;
	if (v1.mySize != mySize){
		throw invalid_argument("The vectors aren't of the same size!");
	}
	//	returnVec.setSize(mySize);
	for (unsigned i=0; i <mySize; i++){
		product = myArray[i] * v1[i] ;
		returnValue += product;
	}
	return returnValue;
}

//Parameters:filename
//Preconditions: file must exist and have values in it
//Postconditions: file contents are read into array

template<class Item>
void Vec<Item>::readFrom(const string fileName) {
	ifstream fin(fileName);
	string sizestr;
	unsigned size;
	getline(fin,sizestr);
	size = atoi(sizestr.c_str());
	setSize(size);
	string str;
	Item num;
	for (unsigned i=0; i< mySize; i++){
		getline(fin, str);
		num = atoi(str.c_str());
		setItem(i,num);
	}
	fin.close();
}

//Parameters: file name
//Preconditions: file must exist
//Postconditions: vector contents are written into the file

template<class Item>
void Vec<Item>::writeTo(const string fileName){
	ofstream fout(fileName);
	fout << mySize << endl;
	string str;
	Item num;
	for (unsigned i=0; i< mySize; i++){
		num = myArray[i];
		str = to_string(num);
		num = atoi(str.c_str());
		fout << str << endl;
	}
	fout.close();
}




#endif /*VEC_H_*/
