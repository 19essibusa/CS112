///* Vec.h file
// * Student:  Anna Park(akp5), Einstein Essibu(se27)
// * Date: 03 Mar, 2020
// * Begun by: Joel C. Adams, for CS 112 at Calvin University.
// */
//
#ifndef VEC_H_
#define VEC_H_

#include <iostream>
#include <stdexcept>
#include <cassert>
#include <fstream>
using namespace std;

template<class Item>
class Vec {

public:
	Vec();
	Vec(unsigned size);
	Vec(const Vec& original);
	virtual ~Vec();
	Vec& operator=(const Vec& original);
	unsigned getSize() const;
	void setItem(unsigned index, const Item& it);
	Item getItem(unsigned index) const;
	void setSize(unsigned newSize);
	bool operator==(const Vec& v2) const;
	void writeTo(ostream& out) const;
	void readFrom(istream& in);
	const Item& operator[](unsigned index) const;
	bool operator!=(const Vec& v2);
	void readFrom(const string& fileName);
	Vec operator+(Vec& v2);
	Vec operator-(const Vec& v2);
	void writeTo(string filename);
	double operator*(const Vec& v2);
	Item& operator[](unsigned index);


private:
	unsigned mySize;
	Item* myArray;
	friend class VecTester;
};

// Default constructor for Vec class
template <class Item>
Vec<Item>::Vec() {
	mySize = 0;
	myArray = NULL;
}

// Explicit constructor for Vec class
template <class Item>
Vec<Item>::Vec(unsigned size) {
	mySize = size;
	if (size > 0) {
		myArray = new Item [size]();
	}
	else {
		myArray = NULL;
	}
}

// Copy constructor for Vec class
template <class Item>
Vec<Item>::Vec(const Vec& original) {
	mySize = original.mySize;
	if (original.mySize > 0) {
		myArray = new Item [mySize] ();
		for (unsigned i = 0; i < mySize; ++i) {
			myArray[i] = original.myArray[i];
		}
	}
	else {
		myArray = NULL;
	}
}

//Destructor for Vec class
template <class Item>
Vec<Item>::~Vec() {
	delete [] myArray;
	myArray = NULL;
	mySize = 0;
}

// Assignment operator for Vec class
template <class Item>
Vec<Item>& Vec<Item>::operator=(const Vec<Item>& original) {

      if (this != &original) {
    	  if (mySize != original.mySize) {
    		  if (mySize > 0) {
    			  delete [] myArray;
    			  myArray = NULL;
    		  }
    		  if (original.mySize > 0) {
    			  myArray = new Item [mySize] ();

    		  }
    		  mySize = original.mySize;
    	  }
    	  for (unsigned i = 0; i < mySize; ++i) {
    		  myArray[i] = original.myArray[i];
    	  }
      }

      return *this;
}

// getSize method for Vec class
template <class Item>
unsigned Vec<Item>::getSize() const {
	return mySize;
   }

// setItem method for Vec class
template <class Item>
void Vec<Item>::setItem(unsigned index, const Item& it) {

	if (mySize <= index or index < 0) {
		throw range_error("Invalid index");
	}
	else {
		myArray[index] = it;
	}

}

// getItem method for Vec class
template <class Item>
Item Vec<Item>::getItem(unsigned index) const {

	if (mySize <= index or index < 0) {
		throw range_error("Invalid index");
	}
	else {
		return myArray[index];
	}

}

// setSize method for Vec class
template <class Item>
void Vec<Item>::setSize(unsigned newSize) {

	if (mySize != newSize) {
		if (newSize == 0) {
			delete [] myArray;
			myArray = NULL;
			mySize = 0;
		}
		else {
			Item *newArray = new Item[newSize];

			if (mySize < newSize) {
				for (unsigned i = 0; i < mySize; ++i) {
					newArray[i] = myArray[i];
				}
				for (unsigned i = mySize; i < newSize; ++i) {
					newArray[i] = 0;
				}
			}
			else {
				for (unsigned i = 0; i < newSize; ++i) {
					newArray[i] = myArray[i];
				}
			}
			mySize = newSize;
			delete [] myArray;
			myArray = newArray;
		}
	}
}

// Equality method for Vec class
template <class Item>
bool Vec<Item>::operator==(const Vec<Item>& v2) const {

	if (mySize != v2.getSize() ) {
		return false;
	}
	for (unsigned i = 0; i < mySize; ++i) {
		if (myArray[i] != v2.myArray[i]) {
			return false;
		}
	}
	return true;

}

// writeTo method for Vec class
template <class Item>
void Vec<Item>::writeTo(ostream& out) const {

	for (unsigned i = 0; i < mySize; ++i) {
		out << myArray[i];
	}
}

// readFrom method for Vec class
template <class Item>
void Vec<Item>::readFrom(istream& in) {

	for (unsigned i = 0; i < mySize; ++i) {
		in >> myArray[i];
	}
}

/* operator[]() retrieves the value of index i.
* parameter: index.
* precondition: index must be greater than mySize.
* postcondition: returns index of myArray (i).
*/
template <class Item>
const Item& Vec<Item>::operator[](unsigned index) const {

	if (index >= mySize ) {
			throw range_error("Invalid index");
	}

	return myArray[index];
}

template <class Item>
Item& Vec<Item>::operator[](unsigned index){

	if (index >= mySize) {
		throw range_error("Invalid index");
	}

	return myArray[index];
}
/* Ethan Walters' Methods*/


/* operator!=() tests inequality on vectors.
* parameter: Vec (const).
* precondition: Vec size
* postcondition: returns true if v1 != v2 and false if v1 != v3.
*/
template <class Item>
bool Vec<Item>::operator!=(const Vec& v2) {

	if (mySize != v2.getSize() ) {
		return true;
	}
	if (mySize == v2.getSize() ) {
		for (unsigned i = 0; i < mySize; ++i) {
			if (myArray[i] != v2.myArray[i]) {
				return true;
			}
		}

	}
	return false;
}

/* readFrom() takes values stored in fileName and puts them in v3.
* parameter: fileName (string).
* precondition: delete myArray to avoid memory leakage.
* postcondition: v3 stores values from fileName.
*/
template <class Item>
void Vec<Item>::readFrom(const string& fileName) {

	ifstream inStream(fileName);

	inStream >> mySize;

	delete [] myArray;
	myArray = new Item[mySize];

	for (unsigned i = 0; i < mySize; ++i) {
		inStream >> myArray[i];
	}

	inStream.close();
}

/* operator+() adds vector values together
* parameter: Vec & v2
* precondition: two vecs
* postcondition: v3 contains values from v1 and v2.
*/
template <class Item>
Vec<Item> Vec<Item>::operator+(Vec& v2) {
	Vec v3(mySize);
	for (unsigned i; i < mySize; ++i) {
		v3.myArray[i] = myArray[i] + v2.myArray[i];
	}
	return v3;
}

/* Nathan Bouman's Methods */

//Subtraction
template <class Item>
Vec<Item> Vec<Item>::operator-(const Vec& v2){
	Vec v3(mySize);
	if (mySize != v2.mySize){
		throw invalid_argument("Invalid Argument");
	}
	else if (v2.mySize == 0){
		return v3;
	}
	for (unsigned i = 0; i < mySize; i++){
		v3.myArray[i] = myArray[i] - v2.myArray[i];
	}
	return v3;
}
//writeTo
template <class Item>
void Vec<Item>::writeTo(string fileName){
	ofstream fout (fileName.c_str());
	assert(fout.is_open());
	fout << mySize << '\n';
	for (unsigned i = 0; i < mySize; i++){
		fout << myArray[i] << '\n';
	}
	fout.close();
}
//Dot Product
template <class Item>
double Vec<Item>::operator*(const Vec& v2){
	Item product = 0;
	if (mySize != v2.mySize){
		throw invalid_argument("vectors have different sizes");
	}else if (v2.mySize == 0){
		return product;
	}
	for (unsigned i = 0; i < mySize; i++){
		product += myArray[i] * v2.myArray[i];
	}
	return product;
}

#endif /*VEC_H_*/
