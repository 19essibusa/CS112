 */

#ifndef LINKED_QUEUE_H_
#define LINKED_QUEUE_H_

#include "QueueException.h"

typedef int Item;

class LinkedQueue {
public:
	LinkedQueue(const LinkedQueue& original);
	virtual ~LinkedQueue();
	LinkedQueue& operator=(const LinkedQueue& original);
	unsigned getSize() const { return mySize; }
	bool isEmpty() const { return mySize == 0; }
	bool isFull() const { return false; }

	LinkedQueue();
	void append(const Item& it);
	Item getFirst() const;
	Item getLast() const;
	Item remove();
protected:
	void makeCopyOf(const LinkedQueue& original);
private:
	unsigned mySize;
	struct Node {
		Item myItem;
		Node * myNextPtr;
		
		Node(const Item& it, Node* nextPtr) { myItem = it; myNextPtr = nextPtr; }
		~Node() { delete myNextPtr; }
	};
	Node * myFirstPtr;
	Node * myLastPtr;

	friend class LinkedQueueTester;
};

#endif /*LINKED_QUEUE_H_*/
#include "LinkedQueueTester.h"
#include <cassert>
#include <iostream>
#include <cstdlib>
using namespace std;


void LinkedQueueTester::runTests() {
	cout << "Testing class LinkedQueue..." << endl;
	testConstructor();
	testAppend();
	testRemove();
	testCopyConstructor();
	testAssignment();
	cout << "All tests passed!\n" << endl;
}

void LinkedQueueTester::testAssignment() {
	cout << "- testing assignment... " << flush;
	// empty-to-empty;
	LinkedQueue q1;
	LinkedQueue q2;
	q1 = q2;
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getSize() == 0 );
	assert( q1.myFirstPtr == NULL );
	assert( q1.myLastPtr == NULL );
	cout << " 1 " << flush;
	//non-empty to empty
	LinkedQueue q3;
	LinkedQueue q4;
	q4.append(11);
	q4.append(22);
	q4.append(33);
	q3 = q4;
	assert( !q3.isEmpty() );
	assert( !q3.isFull() );
	assert( q3.getSize() == 3 );
	assert( q3.getFirst() == q4.getFirst() );
	assert( q3.getLast() == q4.getLast() );
	assert( q3.myFirstPtr != q4.myFirstPtr );
	assert( q3.myLastPtr != q4.myLastPtr );
	cout << " 2 " << flush;
	// empty to non-empty
	LinkedQueue q5;
	q5.append(11);
	q5.append(22);
	q5.append(33);
	q5.append(44);
	LinkedQueue q6;
	q5 = q6;
	assert( !q5.isFull() );
	assert( q5.isEmpty() );
	assert( q5.getSize() == 0 );
	assert( q5.myFirstPtr == NULL );
	assert( q5.myLastPtr == NULL );
	cout << " 3 " << flush;
	// both non-empty, larger-to-smaller
	LinkedQueue q7;
	q7.append(11);
	LinkedQueue q8;
	q8.append(22);
	q8.append(33);
	q8.append(44);
	q7 = q8;
	assert( !q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.getSize() == 3 );
	assert( q7.myFirstPtr != q8.myFirstPtr );
	assert( q7.myLastPtr != q8.myLastPtr );
	assert( q7.getFirst() == q8.getFirst() );
	assert( q7.getLast() == q8.getLast() );
	cout << " 4 " << flush;
	// both non-empty, smaller-to-larger
	LinkedQueue q9;
	q9.append(55);
	q9.append(66);
	q7 = q9;
	assert( !q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.getSize() == 2 );
	assert( q7.myFirstPtr != q9.myFirstPtr );
	assert( q7.myLastPtr != q9.myLastPtr );
	assert( q7.getFirst() == q9.getFirst() );
	assert( q7.getLast() == q9.getLast() );
	cout << " 5 " << flush;
	// self assignment
	q8 = q8;
	assert( !q8.isFull() );
	assert( !q8.isEmpty() );
	assert( q8.getSize() == 3 );
	assert( q8.getFirst() == 22 );
	assert( q8.myFirstPtr->myNextPtr->myItem == 33 );
	assert( q8.getLast() == 44 );
	cout << " 6 " << flush;
	// chaining
	q1 = q5 = q8;
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getSize() == 3 );
	assert( q1.getFirst() == 22 );
	assert( q1.myFirstPtr->myNextPtr->myItem == 33 );
	assert( q1.getLast() == 44 );
	assert( q1.myFirstPtr != q5.myFirstPtr );
	assert( q1.myFirstPtr != q8.myFirstPtr );
	assert( q5.myFirstPtr != q8.myFirstPtr );
	assert( q1.myLastPtr != q5.myLastPtr );
	assert( q1.myLastPtr != q8.myLastPtr );
	assert( q5.myLastPtr != q8.myLastPtr );
	cout << " 7 " << flush;
	cout << "Passed!" << endl;
}
//
void LinkedQueueTester::testCopyConstructor() {
	cout << "- testing copy constructor... " << flush;
	// empty queue
	LinkedQueue q1;
	LinkedQueue q2(q1);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myFirstPtr == NULL );
	assert( q2.myLastPtr == NULL );
	assert( q2.getSize() == 0 );
	cout << " 1 " << flush;
	// queue of 3 items
	LinkedQueue q3;
	q3.append(11);
	q3.append(22);
	q3.append(33);
	LinkedQueue q4(q3);
	assert( !q4.isFull() );
	assert( !q4.isEmpty() );
	assert( q4.myFirstPtr != q3.myFirstPtr );
	assert( q4.myLastPtr != q3.myLastPtr );
	assert( q4.getFirst() == 11 );
	assert( q4.myFirstPtr->myNextPtr->myItem == 22 );
	assert( q4.getLast() == 33 );
	assert( q4.getSize() == 3 );
	assert( q4.myFirstPtr != q3.myFirstPtr );
	assert( q4.myLastPtr != q3.myLastPtr );
 	cout << " 2 " << flush;
	cout << "Passed!" << endl;
}

void LinkedQueueTester::testRemove() {
	cout << "- testing remove()... " << flush;
	LinkedQueue q1;
	cout << " 0 " << flush;
	// check with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 1\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 1 " << flush;
	}
//	// check with 1 item
	q1.append(1);
	assert( !q1.isEmpty() );
	assert( q1.remove() == 1 );
	assert( q1.isEmpty() );
	cout << " 2 " << flush;
	// check with 2 items
	q1.append(11);
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 11 );
	assert( q1.getFirst() == 22 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 22 );
	assert( q1.isEmpty() );
	cout << " 3 " << flush;
	// try several values
	q1.append(111);
	q1.append(222);
	q1.append(333);
	q1.append(444);
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 111 );
	assert( q1.getLast() == 444 );
	// now start removing them
	assert( q1.remove() == 111 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 222 );
	assert( q1.getLast() == 444 );
    cout << " 4a " << flush;
	assert( q1.remove() == 222 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 333 );
	assert( q1.getLast() == 444 );
    cout << " 4b " << flush;
	assert( q1.remove() == 333 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 444 );
	assert( q1.getLast() == 444 );
    cout << " 4c " << flush;
	assert( q1.remove() == 444 );
	assert( !q1.isFull() );
	assert( q1.isEmpty() );
    cout << " 4d " << flush;
	// recheck with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 2\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 5 " << flush;
	}
	cout << "Passed!" << endl;
}
//
void LinkedQueueTester::testAppend() {
	cout << "- testing append(), getFirst(), getLast(), ... " << flush;
	LinkedQueue q1;
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	try {
		q1.getFirst();
		cerr << "\ngetFirst() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0a " << flush;
	}
	try {
		q1.getLast();
		cerr << "\ngetLast() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0b " << flush;
	}
	q1.append(11);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 11 );
	cout << " 1 " << flush;
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	cout << " 2 " << flush;
	q1.append(33);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 33 );
	cout << " 3 " << flush;
	q1.append(44);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 44 );
	cout << " 4 " << flush;
	cout << "Passed!" << endl;
}
//
void LinkedQueueTester::testConstructor() {
	cout << "- testing constructor... " << flush;
	// linked queues have no capacity
	LinkedQueue q1;
	assert( q1.getSize() == 0 );
	assert( q1.myFirstPtr == NULL );
	assert( q1.myLastPtr == NULL );
 	cout << " Passed!" << endl;
}

#ifndef LINKEDQUEUETESTER_H_
#define LINKEDQUEUETESTER_H_

#include "LinkedQueue.h"

class LinkedQueueTester {
public:
	void runTests();
	void testConstructor();
	void testAppend();
	void testRemove();
	void testCopyConstructor();
	void testAssignment();
};

#endif /*LINKEDQUEUETESTER_H_*/
 ***n Onward
 ***
by Felicia Lamport
extended by Joel Adams        
 ***
The learned men of Rome
could turn a palindrome
but they were not the first.
 ***
For Adam, says the myth,
began conversing with
a sentence that reversed:
 ***am, I'm Adam"
seemed
a phrase to be esteemed
the moment it was popped.
But that was not to be
- his lady instantly said
 ***"
which left it topped.
 ***
 ***damned Eden; mad Eve
bore two sons,
as goes the fable,
the first named
 ***, a maniac,
who slew his brother Abel.
 ***ived as a devil, eh?
Violence begat violence, until today
 ***anic in a pew,
the cycle turns anew
and descendents of Ned Ludd
 ***umb mobs -- bomb mud.
 ***
Asked his favorite dessert, Archimedes said,
 ***refer PI"
 ***
And Napoleon, post-Josephine, mused,
 ***e was I, ere I saw Elba,"
as he met his Waterloo, confused.
 ***
Anonymous, the most
prolific bard, can boast
of being host
to these:
 ***
 *** it a car or a cat I saw ?"
 ***
 ***e men interpret nine memos."
 ***
 ***d did I live, evil I did dwel."
 ***
 *** at noon taxes."
 ***
 ***an, a plan, a canal, Panama!"
 ***
 ***p, murder us not, tonsured rumpots!"
 ***
 ***aw? No, too stupid a fad. I put soot on warts."
 ***
 ***, note: I dissent. A fast never prevents a fatness. I diet on cod."
 ***
 ***, a red nude, peeped under a yak."
 ***
and that marvel of marvels:
 ***
 *** on a potato pan, Otis!"
 ***
What span, what palindromic bliss!
 ***
I've wrung the alphabet
repeatedly to get
a Janus-phrase so spry
at backwards somersaults.
But as each hope turns false,
in words, alas, drown I. ***
in words, alas, drown I. ***
Drawn Onward ***

by Felicia Lamport
extended by Joel Adams        

The learned men of Rome
could turn a palindrome
but they were not the first.

For Adam, says the myth,
began conversing with
a sentence that reversed:
"Madam, I'm Adam" ***
seemed
a phrase to be esteemed
the moment it was popped.
But that was not to be
- his lady instantly said
"Eve" ***
which left it topped.

Eve damned Eden; mad Eve ***
bore two sons,
as goes the fable,
the first named
Cain, a maniac, ***
who slew his brother Abel.
He lived as a devil, eh? ***
Violence begat violence, until today
we panic in a pew, ***
the cycle turns anew
and descendents of Ned Ludd
-- dumb mobs -- bomb mud. ***

Asked his favorite dessert, Archimedes said,
"I prefer PI" ***

And Napoleon, post-Josephine, mused,
"Able was I, ere I saw Elba," ***
as he met his Waterloo, confused.

Anonymous, the most
prolific bard, can boast
of being host
to these:

"Was it a car or a cat I saw ?" ***

"Some men interpret nine memos." ***

"Lewd did I live, evil I did dwel." ***

"Sex at noon taxes." ***

"A man, a plan, a canal, Panama!" ***

"Stop, murder us not, tonsured rumpots!" ***

"Straw? No, too stupid a fad. I put soot on warts." ***

"Doc, note: I dissent. A fast never prevents a fatness. I diet on cod." ***

"Kay, a red nude, peeped under a yak." ***

and that marvel of marvels:

"Sit on a potato pan, Otis!" ***

What span, what palindromic bliss!

I've wrung the alphabet
repeatedly to get
a Janus-phrase so spry
at backwards somersaults.
But as each hope turns false,
in words, alas, drown I. ***


/*
 * Palindrome.cpp
 *
 *  Created on: Apr 19, 2020
 *      Author: Einstein Essibu
 */

#include "PalindromeTester.h"
#include <cctype>

// Constructor
PalindromeChecker::PalindromeChecker(const string& fileNameIn, const string& fileNameOut) {
	myFileIn = fileNameIn;
	myFileOut = fileNameOut;
	palindromeDetector(myFileIn, myFileOut);
}


bool PalindromeChecker::isPalindrome(const string& palindrome) {
	if (palindrome.length() == 0) {
		return false;
	}
	Stack<char> s1(1);
	ArrayQueue<char> q1(1);

	for (unsigned i = 0; i < palindrome.length(); i++) {
		if (isalpha(palindrome[i])) {
			try {
				q1.append(tolower(palindrome[i]));
			} catch (FullQueueException& se) {
				q1.setCapacity(q1.getCapacity() * 2);
				q1.append(tolower(palindrome[i]));
			}
			try {
				s1.push(tolower(palindrome[i]));
			} catch (StackException& se) {
				s1.setCapacity(s1.getCapacity() * 2);
				s1.push(tolower(palindrome[i]));
			}
		}
	}

	char ch1;
	char ch2;
	unsigned length = q1.getSize();

	for (unsigned i = 0; i < length; i++) {
		ch1 = s1.pop();
		ch2 = q1.remove();
		if (ch1 != ch2) {
			return false;
		}
	}
	return true;
}

// adds " ***" when line is a palindrome
void PalindromeChecker::palindromeDetector(const string& fileNameIn, const string& fileNameOut) {
	ifstream fin(fileNameIn.c_str());
		ofstream fout(fileNameOut.c_str());
		string tempStr;
		while (fin) {
			getline(fin, tempStr);

			if (isPalindrome(tempStr)) {
				fout << tempStr + " ***" << endl;
			} else {
				fout << tempStr << endl;
			}
		}
		fin.close();
		fout.close();
	}






//
//
/*
 * Palindrome.h
 *
 *  Created on: Apr 20, 2020
 *      Author: Einstein Essibu
 */

#ifndef PALINDROMECHECKER_H_
#define PALINDROMECHECKER_H_
#include "Stack.h"
#include "ArrayQueue.h"
#include <fstream>
#include <cassert>
#include <cstdlib>
using namespace std;

class PalindromeChecker {
public:
	PalindromeChecker(const string& fileNameIn, const string& fileNameOut);
	void palindromeDetector(const string& fileNameIn, const string& fileNameOut);
	bool isPalindrome(const string& line);
private:
	string myFileIn;
	string myFileOut;
};



#endif /* PALINDROMECHECKER_H_ */
///*
// * PalindromeTester.cpp
// *
// *  Created on: Apr 20,2020
// *      Author: Einstein Essibu
// */
//


#include "PalindromeTester.h"
#include <cassert>


void PalindromeTester::runTests() {
	cout << "Testing class PalindromeDetector..." << endl;
	testIsPalindrome();
	testPalindromeDetector();
	cout << "All tests passed!\n" << endl;
}

void PalindromeTester::testIsPalindrome() {


	cout << "- testing isPalindrome" << flush;
	PalindromeChecker pc("In.txt", "Out.txt");
	assert(!pc.isPalindrome(""));
	cout << " 0 " << flush;
	string palindrome1 = "civic";
	assert(pc.isPalindrome(palindrome1));
	cout << " 1 " << flush;
	string palindrome2 = "ci vic";
	assert( pc.isPalindrome(palindrome2) );
	cout << " 2 " << flush;
	string palindrome3 = "Ci Vic";
	assert(pc.isPalindrome (palindrome3));
	cout << " 3 " << flush;
	string palindrome4 = "C@$!^&i**v*ic@$";
	assert( pc.isPalindrome(palindrome4) );
	cout << " 4 " << flush;
	string palindrome5 = "Hi Einstein";
	assert( !pc.isPalindrome(palindrome5) );
	cout << " 5 " << flush;
	cout << "Passed!" << endl;
}

void PalindromeTester::testPalindromeDetector() {
	cout << "- testing palindromeDetector" << flush;
	PalindromeChecker p("InwardFile.txt", "OutwardFile.txt");
		ifstream fin("InwardFile.txt");
		ifstream fout("OutwardFile.txt");
		string tempStrIn, tempStrOut;

		while (fin) {
			getline(fin, tempStrIn);
			getline(fout, tempStrOut);
			if (p.isPalindrome(tempStrIn)) {
				assert( tempStrOut == tempStrIn + " ***" );
			} else if (!p.isPalindrome(tempStrIn)) {
				assert( tempStrOut == tempStrIn + "" );
			} else {
				assert( false );
			}
		}

		fin.close();
		fout.close();
		cout << " Passed!" << endl;
	}
/*
 * PalindromeTester.h
 *
 *  Created on: Apr 19, 2020
 *      Author: Einstein Essibu
 */

#ifndef PALINDROMETESTER_H_
#define PALINDROMETESTER_H_
#include "Palindrome.h"

class PalindromeTester {
public:
	void runTests();
	void testIsPalindrome();
	void testPalindromeDetector();
};

#endif /* PALINDROMETESTER_H_ */
/* QueueException.h provides a simple exception class for Queues to throw,
 *   plus subclasses (EmptyQueueException, FullQueueException)
 *   for more fine-grained error-handling.
 * See Exception.h for its superclass.
 * Joel Adams, for CS 112 at Calvin University.
 */
 
#ifndef QUEUEEXCEPTION_H_
#define QUEUEEXCEPTION_H_

#include "Exception.h"

class QueueException : public Exception {
public:
   QueueException(const string& whereThrown, const string& message)
   : Exception(whereThrown, message)
   {}
   
   virtual string className() const {
   	 return "QueueException";
   }
};

class EmptyQueueException : public QueueException {
public:
   EmptyQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is empty")
   {}
   
   virtual string className() const {
   	  return "EmptyQueueException";
   }
};

class FullQueueException : public QueueException {
public:
   FullQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is full")
   {}
   
   virtual string className() const {
   	  return "FullQueueException";
   }
};


#endif /*QUEUEEXCEPTION_H_*/

/* StackException.h models exceptions in stack operations.
 * Joel Adams, for CS 112 at Calvin University.
 * Student Name: Einstein Essibu
 * Date:
 */

#ifndef STACK_EXCEPTION
#define STACK_EXCEPTION

#include <iostream>
using namespace std;

 
class StackException {
public:
   StackException(const string& whereThrown,
                  const string& message) { 
       myLocation = whereThrown; 
       myMessage = message; 
   }

   string asString() const {
       return "*** StackException in " +
               myLocation + ": " + myMessage; 
   }

private:
   string myLocation;
   string myMessage;
};  // StackException


/* Function to allow a StackException (or a subclass) to be displayed
 * via an ostream.
 * Parameters: out, an ostream;
 *             se, a StackException.
 * Postcondition: the string representation of se has been inserted
 * into out
 *             && return-value == out.
 */
inline ostream& operator<<(ostream& out, const StackException& se) {
      out << se.asString();
      return out;
}

#endif

/* Stack.h provides a (dynamic-array-based) Stack class.
 * Joel Adams, for CS 112 at Calvin University
 * Student Name: Einstein Essibu
 * Date: 4/4/2020
 * 
 * Invariant: mySize == 0 && isEmpty() && !isFull()
 *         || mySize == myCapacity && !isEmpty() && isFull()
 *         || mySize > 0 && mySize < myCapacity && !isEmpty() && !isFull().
 * Notes: 
 * 1. Member mySize always contains the index of the next empty space in myArray
 *        (the index of the array element into which the next pushed item will be placed).
 * 2. Sending push() to a full Stack throws the exception Stack::Overflow.
 * 3. Sending pop() or peekTop() to an empty Stack throws the exception Stack::Underflow.
 */

#ifndef STACK_H_
#define STACK_H_

#include <string>
#include <iostream>
#include "StackException.h"

using namespace std;

//typedef int  Item;

template <class Item>
class Stack {
public:
	Stack(unsigned capacity);
	Stack(const Stack<Item>& original);
	~Stack();
	Stack<Item>& operator=(const Stack<Item>& original);
	bool isEmpty() const;
	bool isFull() const;
	Item peekTop() const;
	void push(const Item& it);
	Item pop();
	unsigned getSize() const { return mySize; }
	unsigned getCapacity() const { return myCapacity; }
	void setCapacity(unsigned newCap);

protected:
	void makeCopyOf(const Stack<Item>& original);

private:
	unsigned myCapacity;
	unsigned mySize;
	Item*    myArray;
	friend class StackTester;
};

template <class Item>
Stack<Item>::Stack(unsigned capacity) {
	if (capacity < 1) {
		throw StackException("Stack(size)", "size must be positive!");
	}
	mySize = 0;
	myCapacity = capacity;
	myArray = new Item[capacity];
}

/* copy constructor
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original.
 */
template <class Item>
Stack<Item>::Stack(const Stack<Item>& original) { // @suppress("Class members should be properly initialized")
	makeCopyOf(original);
}

/* utility method containing code refactored from
 *  the copy constructor and operator=.
 * Parameter: original, a Stack (const reference).
 * Precondition: original.myCapacity > 0.
 * Postcondition: I am a copy of original.
 */
template <class Item>
void Stack<Item>::makeCopyOf(const Stack<Item>& original) {
	myCapacity = original.myCapacity;
	myArray = new Item[myCapacity];

	for (unsigned i = 0; i < myCapacity; i++) {
		myArray[i] = original.myArray[i];
	}
	mySize = original.mySize;
}

/* destructor
 * Postcondition: myCapacity == 0 && mySize == 0
 *             && myArray has been deallocated.
 */
template <class Item>
Stack<Item>::~Stack() {
	delete [] myArray;
	myArray = NULL;
	myCapacity = 0;
	mySize = 0;
}

/* assignment operator
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original
 *              && I have been returned.
 */
template <class Item>
Stack<Item>& Stack<Item>::operator=(const Stack<Item>& original) {
	if (this != &original) {
		delete [] myArray;
		makeCopyOf(original);
	}
	return *this;
}

/* Checks if the stack is empty
 * returns: true if the size is 0, otherwise false
 */
template <class Item>
bool Stack<Item>::isEmpty() const {
	if (mySize != 0) {
		return false;
	}
	return true;
}

/* Checks if the stack is full
 * returns: true if the size is equal to capacity, otherwise false
 */
template <class Item>
bool Stack<Item>::isFull() const {
	if (mySize != myCapacity) {
		return false;
	}
	return true;
}

/* Getter for the top item of our stack
 * returns: a read-only reference of the top Item
 */
template <class Item>
Item Stack<Item>::peekTop() const {
	if ( isEmpty() ) {
		throw StackException("peekTop()", "stack is empty");
	}
	return myArray[mySize - 1];
}

/* Adds item to the top of the stack
 * @params: Some Item item
 * Precondition:  Stack object
 * Postcontition: Same stack object with new item it added to the end if there is room for it
 */
template <class Item>
void Stack<Item>::push(const Item& item) {
	if ( isFull() ) {
		throw StackException("push()", "stack is full!");
	}
	myArray[mySize] = item;
	mySize++;
}

/* "Removes" top item from stack and returns it
 * returns: copy of top item of stack
 * Precondition:  Stack object with some amount of items in it
 * Postcondition: Same stack object with the size reduced by 1.
 */
template <class Item>
Item Stack<Item>::pop() {
	if ( isEmpty() ) {
		throw StackException("pop()", "stack is empty!");
	}
	--mySize;
	return myArray[mySize];
}

/* Changes capacity of stack
 * @params: unsigned new capacity
 */
template <class Item>
void Stack<Item>::setCapacity(unsigned newCap) {
	if (newCap < mySize) {
		throw StackException("setCapacity()", "New capacity must be equal to or larger than size!");
	}

	Item* tempArray = new Item[newCap];
	for ( unsigned i = 0; i < myCapacity; i++ ) {
		tempArray[i] = myArray[i];
	}
	delete [] myArray;
	myArray = tempArray;
	myCapacity = newCap;
}

#endif
/* tester.cpp drives the testing of the Queue classes.
 * Joel Adams, for CS 112 at Calvin University.
 */

 #include "ArrayQueueTester.h"
 #include "LinkedQueueTester.h"
#include "PalindromeTester.h"
 
 int main() {
 	ArrayQueueTester aqt;
 	aqt.runTests();
 	LinkedQueueTester lqt;
 	lqt.runTests();
 	PalindromeTester pdt;
 	pdt.runTests();
 }
 
 Testing class ArrayQueue...
- testing constructor...  1  2  Passed!
- testing append(), getFirst(), getLast() ...  0a  0b  1  2  3  4  5 Passed, but wrap-around not tested...
- testing remove()...  0  1  2  3  4a  4b  4c  4d  5  6a  6b  6c Passed!
- testing copy constructor...  1  2  3 Passed!
- testing assignment...  1  2  3  4  5  6  7 Passed!
Testing setCapacity()... 1a 1b 1c 2a 2b 2c 2d 2e 2f 3a 3b 3c 3d 3e 3f 4a 4b 4c 4d 4e 4f 5 6 Passed!
All tests passed!

Testing class LinkedQueue...
- testing constructor...  Passed!
- testing append(), getFirst(), getLast(), ...  0a  0b  1  2  3  4 Passed!
- testing remove()...  0  1  2  3  4a  4b  4c  4d  5 Passed!
- testing copy constructor...  1  2 Passed!
- testing assignment...  1  2  3  4  5  6  7 Passed!
All tests passed!

Testing class PalindromeDetector...
- testing isPalindrome 0  1  2  3  4  5 Passed!
- testing palindromeDetector Passed!
All tests passed!



